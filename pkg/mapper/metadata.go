package mapper

import "strconv"

// Metadata provides per-message metadata passed between vertices.
//
// A vertex could create one or more set of key-value pairs per group-name.
// This is required because a vertex could forward a message to a
// Kafka sink with Kafka headers, and a metrics Sink with some key/value points.

// There will be two kinds of metadata,

// system - generated by the system, exposed as read-only to UDFs
// user - user generated with read-write access
//	|
//	|          +-> [group-m] -> {k1:v1, ... }
//	|          |
//	+-> [user] +-> [group-n] -> {k1:v1, ... }
//	|          |
//	|          +-> [group-o] -> {k1:v1, ... }
//	|
//	|          +-> [group-h] -> {k1:v1, ... }
//	|          |
//	+-> [sys]  +-> [group-i] -> {k1:v1, ... }
//	|
//

// Metadata bundles system and user metadata for a message.
type Metadata struct {
	systemMetadata SystemMetadata
	userMetadata   UserMetadata
}

// SystemMetadata is mapping of group name to key-value pairs
// SystemMetadata wraps system-generated metadata groups per message.
// It is read-only to UDFs
type SystemMetadata struct {
	data map[string]map[string][]byte
}

// newSystemMetadata wraps an existing map into SystemMetadata
// This is for internal use only.
func newSystemMetadata(d map[string]map[string][]byte) SystemMetadata {
	if d == nil {
		d = make(map[string]map[string][]byte)
	}
	return SystemMetadata{data: d}
}

// SystemMetadata returns the system metadata.
// Any changes to the system metadata will be ignored.
func (md Metadata) SystemMetadata() SystemMetadata {
	return md.systemMetadata
}

// UserMetadata wraps user-defined metadata groups per message.
type UserMetadata struct {
	data map[string]map[string][]byte
}

// NewUserMetadata creates an empty UserMetadata.
func NewUserMetadata() UserMetadata {
	return UserMetadata{data: make(map[string]map[string][]byte)}
}

// NewUserMetadataWithData wraps an existing map into UserMetadata.
// If d is nil, an empty map is created.
func NewUserMetadataWithData(d map[string]map[string][]byte) UserMetadata {
	if d == nil {
		d = make(map[string]map[string][]byte)
	}
	return UserMetadata{data: d}
}

// UserMetadata returns the user metadata map.
// The map contains groups, each being a key->[]byte map.
// Usage example: md := datum.Metadata()
// userMetadata := md.UserMetadata()
func (md Metadata) UserMetadata() UserMetadata {
	return md.userMetadata
}

// NewMetadata creates a metadata object initialized with the provided user
// metadata. If nil is passed, an empty user metadata map is created. System
// metadata is populated by the platform and is not set here.
func NewMetadata(userMetadata UserMetadata) Metadata {
	if userMetadata.data == nil {
		userMetadata = NewUserMetadata()
	}
	return Metadata{
		userMetadata: userMetadata,
	}
}

// Data returns the underlying groups map for iteration.
func (md UserMetadata) Data() map[string]map[string][]byte {
	return md.data
}

// SetKVGroup sets a group of key-value pairs under the provided group name.
// Usage example: userMetadata := NewUserMetadata()
// userMetadata.SetKVGroup("group-name", map[string][]byte{"key": []byte("value")})
func (md UserMetadata) SetKVGroup(group string, kv map[string][]byte) {
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group] = kv
}

// AppendKV appends a key-value pair to the user metadata.
// Usage example: userMetadata := NewUserMetadata()
// userMetadata.AppendKV("group-name", "key", []byte("value"))
func (md UserMetadata) AppendKV(group, key string, value []byte) {
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = value
}

// AppendKVString appends a key-value pair with value of string type to the user metadata.
// Usage example: userMetadata := NewUserMetadata()
// userMetadata.AppendKVString("group-name", "key", "value")
func (md UserMetadata) AppendKVString(group, key, value string) {
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = []byte(value)
}

// AppendKVInt appends a key-value pair with value of int type to the user metadata
// Usage example: userMetadata := NewUserMetadata()
// userMetadata.AppendKVInt("group-name", "key", 123)
func (md UserMetadata) AppendKVInt(group, key string, value int) {
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = []byte(strconv.Itoa(value))
}

// RemoveKey removes a key from a group in the user metadata.
// If the key or group is not present, it's a no-op.
// Usage example: md := datum.Metadata()
// userMetadata := md.UserMetadata()
// userMetadata.RemoveKey("group-name", "key")
func (md UserMetadata) RemoveKey(group, key string) {
	delete(md.data[group], key)
}

// RemoveGroup removes a group from the user metadata.
// If the group is not present, it's a no-op.
// Usage example: md := datum.Metadata()
// userMetadata := md.UserMetadata()
// userMetadata.RemoveGroup("group-name")
func (md UserMetadata) RemoveGroup(group string) {
	delete(md.data, group)
}
