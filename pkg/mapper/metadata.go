package mapper

import "strconv"

// Metadata provides per-message metadata passed between vertices.
//
// A vertex could create one or more set of key-value pairs per group-name.
// This is required because a vertex could forward a message to a
// Kafka sink with Kafka headers, and a metrics Sink with some key/value points.

// There will be two kinds of metadata,

// system - generated by the system, exposed as read-only to UDFs
// user - user generated with read-write access
//	|
//	|          +-> [group-m] -> {k1:v1, ... }
//	|          |
//	+-> [user] +-> [group-n] -> {k1:v1, ... }
//	|          |
//	|          +-> [group-o] -> {k1:v1, ... }
//	|
//	|          +-> [group-h] -> {k1:v1, ... }
//	|          |
//	+-> [sys]  +-> [group-i] -> {k1:v1, ... }
//	|
//

// SystemMetadata is mapping of group name to key-value pairs
// SystemMetadata wraps system-generated metadata groups per message.
// It is read-only to UDFs
type SystemMetadata struct {
	data map[string]map[string][]byte
}

// NewSystemMetadata wraps an existing map into SystemMetadata
// This is for internal and testing purposes only.
func NewSystemMetadata(d map[string]map[string][]byte) *SystemMetadata {
	if d == nil {
		d = make(map[string]map[string][]byte)
	}
	return &SystemMetadata{data: d}
}

// Groups returns the groups of the system metadata.
// If there are no groups, it returns an empty slice.
//
// Usage example:
//
//	```go
//	systemMetadata := datum.SystemMetadata()
//	groups := systemMetadata.Groups()
//	```
func (md *SystemMetadata) Groups() []string {
	groups := make([]string, 0, len(md.data))
	for group := range md.data {
		groups = append(groups, group)
	}
	return groups
}

// Keys returns the keys of the system metadata for the given group.
// If the group is not present, it returns an empty slice.
//
// Usage example:
//
//	```go
//	systemMetadata := datum.SystemMetadata()
//	keys := systemMetadata.Keys("group-name")
//	```
func (md *SystemMetadata) Keys(group string) []string {
	keys := make([]string, 0, len(md.data[group]))
	for key := range md.data[group] {
		keys = append(keys, key)
	}
	return keys
}

// Value returns the value of the system metadata for the given group and key.
// If the group or key is not present, it returns an empty slice.
//
// Usage example:
//
//	```go
//	systemMetadata := datum.SystemMetadata()
//	value := systemMetadata.Value("group-name", "key")
//	```
func (md *SystemMetadata) Value(group, key string) []byte {
	return md.data[group][key]
}

// UserMetadata wraps user-defined metadata groups per message.
type UserMetadata struct {
	data map[string]map[string][]byte
}

// NewUserMetadata wraps an existing map into UserMetadata.
// If d is nil, an empty map is created.
func NewUserMetadata(d map[string]map[string][]byte) *UserMetadata {
	if d == nil {
		d = make(map[string]map[string][]byte)
	}
	return &UserMetadata{data: d}
}

// Groups returns the groups of the user metadata.
// If there are no groups, it returns an empty slice.
//
// Usage example:
//
//	```go
//	userMetadata := datum.UserMetadata()
//	groups := userMetadata.Groups()
//	```
func (md *UserMetadata) Groups() []string {
	groups := make([]string, 0, len(md.data))
	for group := range md.data {
		groups = append(groups, group)
	}
	return groups
}

// Keys returns the keys of the user metadata for the given group.
// If the group is not present, it returns an empty slice.
//
// Usage example:
//
//	```go
//	userMetadata := datum.UserMetadata()
//	keys := userMetadata.Keys("group-name")
//	```
func (md *UserMetadata) Keys(group string) []string {
	keys := make([]string, 0, len(md.data[group]))
	for key := range md.data[group] {
		keys = append(keys, key)
	}
	return keys
}

// Value returns the value of the user metadata for the given group and key.
// If the group or key is not present, it returns an empty slice.
//
// Usage example:
//
//	```go
//	userMetadata := datum.UserMetadata()
//	value := userMetadata.Value("group-name", "key")
//	```
func (md *UserMetadata) Value(group, key string) []byte {
	return md.data[group][key]
}

// SetKVGroup sets a group of key-value pairs under the provided group name.
//
// Usage example:
//
//	```go
//	userMetadata := NewUserMetadata()
//	userMetadata.SetKVGroup("group-name", map[string][]byte{"key": []byte("value")})
//	```
func (md *UserMetadata) SetKVGroup(group string, kv map[string][]byte) {
	if md == nil {
		return
	}
	if md.data == nil {
		md.data = make(map[string]map[string][]byte)
	}
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group] = kv
}

// AddKV adds a key-value pair to the user metadata.
//
// Usage example:
//
//	```go
//	userMetadata := NewUserMetadata()
//	userMetadata.AddKV("group-name", "key", []byte("value"))
//	```
func (md *UserMetadata) AddKV(group, key string, value []byte) {
	if md == nil {
		return
	}
	if md.data == nil {
		md.data = make(map[string]map[string][]byte)
	}
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = value
}

// AddKVString adds a key-value pair with value of string type to the user metadata.
//
// Usage example:
//
//	```go
//	userMetadata := NewUserMetadata()
//	userMetadata.AddKVString("group-name", "key", "value")
//	```
func (md *UserMetadata) AddKVString(group, key, value string) {
	if md == nil {
		return
	}
	if md.data == nil {
		md.data = make(map[string]map[string][]byte)
	}
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = []byte(value)
}

// AddKVInt adds a key-value pair with value of int type to the user metadata
//
// Usage example:
//
//	```go
//	userMetadata := NewUserMetadata()
//	userMetadata.AddKVInt("group-name", "key", 123)
//	```
func (md *UserMetadata) AddKVInt(group, key string, value int) {
	if md == nil {
		return
	}
	if md.data == nil {
		md.data = make(map[string]map[string][]byte)
	}
	if md.data[group] == nil {
		md.data[group] = make(map[string][]byte)
	}
	md.data[group][key] = []byte(strconv.Itoa(value))
}

// RemoveKey removes a key from a group in the user metadata.
// If the key or group is not present, it's a no-op.
//
// Usage example:
//
//	```go
//	md := datum.Metadata()
//	userMetadata := md.UserMetadata()
//	userMetadata.RemoveKey("group-name", "key")
//	```
func (md *UserMetadata) RemoveKey(group, key string) {
	if md == nil || md.data == nil {
		return
	}
	delete(md.data[group], key)
}

// RemoveGroup removes a group from the user metadata.
// If the group is not present, it's a no-op.
//
// Usage example:
//
//	```go
//	md := datum.Metadata()
//	userMetadata := md.UserMetadata()
//	userMetadata.RemoveGroup("group-name")
//	```
func (md *UserMetadata) RemoveGroup(group string) {
	if md == nil || md.data == nil {
		return
	}
	delete(md.data, group)
}
